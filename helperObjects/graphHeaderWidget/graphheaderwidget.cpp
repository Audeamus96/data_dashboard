#include "graphheaderwidget.h"
#include "helperObjects/dataMultiplexer/datamultiplexer.h"
#include <mainwindow.h>

#include <QWidget>
#include <QLabel>
#include <QObject>
#include <QPushButton>

/**
 * @brief Create header widget
 *      Header widget contains main layout (horiz.) and two vertical
 *      widgets inside of it containing labels and combo-boxes
 *  1111111111111111
 *  1 2222 3333 * /1
 *  1 2  2 3  3 * /1
 *  1 2222 3333 * /1
 *  1111111111111111
 *      Stars depict area where extra horizontal widgets can be injected
 *      before \ref AppendHorSpacer is called. Finally, horizontal spacer
 *      is added in the back, shown in /
 * @param chnnelNum Number of input channels
 */
graphHeaderWidget::graphHeaderWidget(uint8_t chnnelNum, QString ParentWinName)
    :  _parentWinName(ParentWinName), _parent(nullptr)
{
    //  Create layouts
    _mainLayout = new QHBoxLayout();
    QVBoxLayout *chLabels = new QVBoxLayout();
    QVBoxLayout *inChannels = new QVBoxLayout();

    _mainLayout->addLayout(chLabels);
    _mainLayout->addLayout(inChannels);

    _inputChannelList = new uint8_t[chnnelNum];

    //  Loop to create channel labels and drop-downs
    for (uint8_t i = 0; i < chnnelNum; i++)
    {
        _inChLabel.push_back(new QLabel());
        _inChLabel.back()->setText("Channel "+QString::number(i));
        _inChLabel.back()->setToolTip( _STYLE_TOOLTIP_(\
                    "Select which input channel should be used as channel " \
                    + QString::number(i) + " in the plot"));
        _inChLabel.back()->setFixedHeight(22);

        _inCh.push_back(new QComboBox());
        //  Set fixed height for nicer look
        _inCh.back()->setFixedHeight(22);
        _inCh.back()->setToolTip( _STYLE_TOOLTIP_(\
                    "Select which input channel should be used as channel " \
                    + QString::number(i) + " in the plot"));

        //  Trigger 'ComboBoxUpdated' function here whenever the combo-boxes
        //  get updated
        QObject::connect(_inCh[i],
                QOverload<int>::of(&QComboBox::currentIndexChanged),
                this,
                &graphHeaderWidget::ComboBoxUpdated);

        chLabels->addWidget(_inChLabel.back());
        inChannels->addWidget(_inCh.back());
    }
    UpdateChannelDropdown();
}

/**
 * @brief Add horizontal spacer to the end of the layout
 *      Seals the header widget once the header contains all the
 *      necessary fields
 */
void graphHeaderWidget::AppendHorSpacer()
{
    _mainLayout->addSpacerItem(new QSpacerItem (20,20,QSizePolicy::Expanding));
}

/**
 * @brief [Slot] Called from mux to refresh the list of channels in the
 *  drop-down menus
 */
void graphHeaderWidget::UpdateChannelDropdown()
{
    QString time = QDateTime::currentDateTime().time().toString();
    emit logLine("Updating channel dropdown for "+_parentWinName);
    for (QComboBox* X : _inCh)
    {
        emit logLine(" Processing");
        //  Save selected entry in an attempt to reselect it after refresh
        QString currentItem = X->currentText();
        //  Clear list
        X->clear();
        //  Insert new list
        X->addItems(DataMultiplexer::GetI().GetChannelList());
        //  Attempt to reselect old value
        int newIndex = X->findText(currentItem);
        if (newIndex >= 0)
            X->setCurrentIndex(newIndex);
    }

    time = QDateTime::currentDateTime().time().toString();
    emit logLine("Finished updating channel dropdown for "+_parentWinName);
}

/**
 * @brief Returns reference to labels so they can be stylize or edited from
 *      external sources
 * @return Reference to the vector of labels
 */
QVector<QLabel*>& graphHeaderWidget::GetLabels()
{
    return _inChLabel;
}

/**
 * @brief Returns array of selected channel names, as selected in combo boxes
 * @return array of channel labels
 */
QVector<QString> graphHeaderWidget::GetChLabels()
{
    QVector<QString> retVal;

    for (QComboBox* X : _inCh)
        retVal.push_back(X->currentText());

    return retVal;
}

/**
 * @brief Returns an array with which channels are selected on the graph
 * @return Vector containing indexes of selected channel in every drop-down
 */
QVector<uint8_t> graphHeaderWidget::GetSelectedChannels()
{
    QVector<uint8_t>retVal;

    for (QComboBox* X : _inCh)
        retVal.push_back(X->currentIndex());

    return retVal;
}

/**
 * @brief Restore the selected channels in their respective drop-downs
 *  provided the list generated by \ref graphHeaderWidget::GetSelectedChannels()
 * @param selectedCh list saying which id to select in which QComboBox
 */
void graphHeaderWidget::SetSelectedChannels(QVector<uint8_t> &selectedCh)
{
    for (uint8_t i = 0; i < _inCh.size(); i++)
        //  Check that current index exists in the array
        if (i < selectedCh.size())
            //  Check that the value on current index does not exceed total
            //  number of index on the list
            if (selectedCh[i] < _inCh[i]->count())
                _inCh[i]->setCurrentIndex(selectedCh[i]);
}

/**
 * @brief Update tooltip of a selected channel
 * @param id Channel ID to be updated
 * @param toolTip String to use as tooltip
 */
void graphHeaderWidget::SetChToolTip(uint8_t id, QString toolTip)
{
    //  Check if Id is valid
    if ((id >= _inCh.size()) || (id >= _inChLabel.size()))
        return;
    _inChLabel[id]->setToolTip( _STYLE_TOOLTIP_(+toolTip+));
    _inCh[id]->setToolTip( _STYLE_TOOLTIP_(+toolTip+));
}
/**
 * @brief Returns main header layout
 * @return main header layout
 */
QHBoxLayout* graphHeaderWidget::GetLayout()
{
    return _mainLayout;
}

/**
 * @brief [Private Slot] Handles pushing an updated list of input channels to
 *      the parent window
 *  Called by the combo-boxes when their value is changed
 */
void graphHeaderWidget::ComboBoxUpdated(const int &)
{
    for (uint8_t i = 0; i < _inCh.size(); i++)
        _inputChannelList[i] = _inCh[i]->currentIndex();

    emit UpdateInputChannels(_inputChannelList);
}

graphHeaderWidget::~graphHeaderWidget()
{
    delete [] _inputChannelList;
}
